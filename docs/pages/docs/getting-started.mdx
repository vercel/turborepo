---
title: Getting Started
description: Create your first monorepo or add Turborepo to an existing project.
---

import Callout from "../../components/callout";
import Beta from "../../components/beta";
import { Tabs, Tab } from '../../components/Tabs'

# Getting Started with Turborepo

## Clone an example or starter monorepo

If you're starting a brand new monorepo, you can get started with a single command.

```sh
npx create-turbo@latest
```

Follow the prompts to bootstrap a brand new Turborepo.

To see more examples and starters, have a look at the [examples directory on GitHub](https://github.com/vercel/turborepo/blob/main/examples)

## Add Turborepo to your existing monorepo

Turborepo was designed to be incrementally adopted. Adding it to an existing monorepo takes only a few minutes.

`turbo` works with [Yarn](https://classic.yarnpkg.com/lang/en/), [npm](https://npmjs.com), and [pnpm](https://pnpm.io/) on the following operating systems:

- macOS darwin 64-bit (Intel), ARM 64-bit (Apple Silicon)
- Linux 32-bit, 64-bit, ARM, ARM 64-bit, MIPS 64-bit Little Endian, PowerPC 64-bit Little Endian, IBM Z 64-bit Big Endian
- Windows 32-bit, 64-bit, ARM 64-bit
- FreeBSD 64-bit, ARM 64-bit
- NetBSD AMD64
- Android ARM 64-bit

### Ensure workspaces are configured

**`turbo` is built on top of Workspaces**â€”A set of features implemented by [npm](https://docs.npmjs.com/cli/v8/using-npm/workspaces#description), [Yarn](https://classic.yarnpkg.com/lang/en/docs/workspaces/), and [pnpm](https://pnpm.io/workspaces) that allows you to manage multiple packages from your local files system from within a singular top-level, root package. Workspaces are required to use `turbo`

When it comes to folder structure, we suggest is applications to be placed the `/apps` folder and packages to go in `/packages` folders, but that's not a requirement.

<Tabs items={['NPM', 'Yarn', 'PNPM']} storageKey="selected-pkg-manager">
  <Tab>
<div/>
Ensure that you have specified all `workspaces` in your root `package.json` like so:

```json filename="package.json"
{
 "workspaces": [
   "packages/*",
   "apps/*"
  ]
}
```

  </Tab>
  <Tab>
<div/>    
Ensure that you have specified all `workspaces` in your root `package.json` like so:

```json filename="package.json"
{
 "workspaces": [
   "packages/*",
   "apps/*"
  ]
}
```

  </Tab>
  <Tab>
<div/>
Ensure that you have specified all `packages` in `pnpm-workspaces.yaml`.
```yaml filename="pnpm-workspace.yaml"
packages:
  - "packages/*"
  - "apps/*"
```
  </Tab>
</Tabs>

Now re-run your NPM client's install command just to be sure.

<Callout>
  Note: Nested workspaces are not supported. You can flatten your workspaces as a workaround.
</Callout>

### Install `turbo`

Add `turbo` as a development dependency in the root of your project.

<Tabs items={['NPM', 'Yarn', 'PNPM']} storageKey="selected-pkg-manager">
  <Tab>
    ```bash
    npm install turbo -D
    ```
  </Tab>
  <Tab>
    ```bash
    yarn add turbo -DW
    ```
  </Tab>
  <Tab>
    ```bash
    pnpm add turbo -DW
    ```
  </Tab>
</Tabs>

The `turbo` package is a little shell that will install the proper `@turborepo/*` packages.

### Create `turbo.json`

In your root directory, create an empty file named `turbo.json`.
This will hold the configuration for Turborepo in your project.
If your git repo's base branch is NOT `origin/master` then you need to specify a `baseBranch` too (for example, ours is set to `origin/main`).

```json filename="./turbo.json"
{
  "$schema": "https://turborepo.org/schema.json",
  "baseBranch": "origin/main"
}
```

### Create a `pipeline`

To define your project's task dependency graph, use the [`pipeline`](./features/pipelines) key in the `turbo.json` configuration file at the root of your project. `turbo` interprets this configuration and conventions to properly schedule, execute, and cache the outputs of the `package.json` scripts defined in all of your workspaces in your monorepo.

Each key in the [`pipeline`](./features/pipelines) object is the name of a `package.json` script that can be executed by [`turbo run`](./reference/command-line-reference#turbo-run-task1-task2-1). You can specify its dependencies with the [`dependsOn`](../reference/configuration#dependson) key beneath it as well as some other options related to [caching](./features/caching).

Packages that do not have have this script defined in their `package.json`'s list of `scripts` will be ignored and skipped over during `turbo run`.

```jsonc filename="./turbo.json"
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      // A package's `build` script depends on that package's
      // topological dependencies' and devDependencies'
      // `build` tasks  being completed first
      // (that's what the `^` symbol signifies).
      "dependsOn": ["^build"]
    },
    "test": {
      // A package's `test` script depends on that package's
      // own `build` script being completed first.
      "dependsOn": ["build"],
      "outputs": [],
      // A package's `test` script should only be rerun when
      // either a `.tsx` or `.ts` file has changed in `src` or `test` folders.
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts", "test/**/*.tsx"]
    },
    "lint": {
      // A package's `lint` script has no dependencies and
      // can be run whenever. It also has no filesystem outputs.
      "outputs": []
    },
    "deploy": {
      // A package's `deploy` script depends on the `build`,
      // `test`, and `lint` scripts of the same package
      // being completed. It also has no filesystem outputs.
      "dependsOn": ["build", "test", "lint"],
      "outputs": []
    }
  }
}
```

The rough execution order for a given package based on the `dependsOn` keys above will be:

1. `build` once its dependencies have run their `build` commands
2. `test` once its _own_ `build` command is finished and has no filesystem outputs (just logs)
3. `lint` can run whenever and has no filesystem outputs (just logs)
4. `deploy` once its _own_ `build`, `test`, and `lint` commands have finished, no outputs

The full pipeline can then be run:

```bash
npx turbo run build test lint deploy
```

Turborepo will then efficiently schedule execution minimizing idle CPUs.

See the [`pipeline`](./features/pipelines) documentation for more details on how to configure your `pipeline`.

### Edit `.gitignore`

Next, add `.turbo` to your `.gitignore` file. The CLI uses these folders for logs and certain task outputs.

```diff
+ .turbo
```

Make sure that your task artifacts (the files you want to be cached) are also ignored. As a rule, any files/folder that you want cached should be gitignored.

```diff
+ build/**
+ dist/**
+ .next/**
```

Now re-run your NPM client's install command just to be sure. You should be good to go now.

## Create `package.json` scripts

Add or update `scripts` in your root `package.json` to call `turbo` scripts.

```jsonc filename="./package.json"
{
  "scripts": {
    "build": "turbo build",
    "test": "turbo test",
    "lint": "turbo lint",
    "dev": "turbo dev"
  }
}
```

## Run stuff!

<Tabs items={['NPM', 'Yarn', 'PNPM']} storageKey="selected-pkg-manager">
  <Tab>
    ```bash
    npm run build
    ```
  </Tab>
  <Tab>
    ```bash
    yarn  build
    ```
  </Tab>
  <Tab>
    ```bash
    pnpm build
    ```
  </Tab>
</Tabs>

Now run it again. Depending on your monorepo setup, some stuff might already be caching properly. If not, no worries! In the next sections, we'll discuss how `turbo` works, how `scope` works, and then how to get caching working after that.

## Setup Remote Caching <Beta/>

A major key ðŸ”‘ to Turborepo's speed is that it is both lazy and efficientâ€”it does the least amount of work possible and it tries to never redo work that's already been done before.
At the moment, Turborepo caches your tasks on your local filesystem (i.e. "single-player mode," if you will). However, what if there was a way to take advantage of the computational work done by your teammates or your CI (i.e. "co-op multiplayer mode")? What if there was a way to teleport and share a single cache across machines? Almost like a "Dropbox" for your Turborepo cache.

> Remote Caching has entered the chat.

Turborepo can use a technique known as Remote Caching to share cache artifacts across machines for an additional speed boost.

<Callout type="error">
  Remote Caching is a powerful feature of Turborepo, but with great power comes great responsibility. Make sure you are caching correctly first and double check handling of environment variables. Please also remember Turborepo treats logs as artifacts, so be aware of what you are printing to the console.
</Callout>

### Link Your Turborepo to Your Remote Cache

Remote caching is available with zero configuration on [Vercel](https://vercel.com?utm_source=turborepo.org&utm_medium=referral&utm_campaign=docs-link).

#### Using Remote Caching for Local development

If you want to link your local turborepo to your Remote Cache you do so by first authenticating the Turborepo CLI with your Vercel account:

```sh
npx turbo login
```

Next, you can link your turborepo to your remote cache by running the following command:

```
npx turbo link
```

Once enabled, make some changes to a package or application you are currently caching and run tasks against it with `turbo run`.
Your cache artifacts will now be stored locally _and_ in your Remote Cache. To verify that this worked, delete your local Turborepo cache:

```sh
rm -rf ./node_modules/.cache/turbo
```

Now run the same build again. If things are working properly, `turbo` should not execute tasks locally, but rather download both the logs and artifacts from your Remote Cache and replay them back to you.

<Callout>
  **Note: When connecting to an sso-enabled Vercel team, you must provide your Team slug as an argument to `npx turbo login`.**
</Callout>
```
npx turbo login --sso-team=<team-slug>
```
