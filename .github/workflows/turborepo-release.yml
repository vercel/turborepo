# Release Pipeline
#
# This release consists of a few steps
#
# 1. Create a staging branch (acts as a lock to prevent concurrent releases)
# 2. Run some smoke tests on that branch
# 3. Build the Rust binary
# 4. Publish JS packages to npm (including turbo itself)
# 5. Create the git tag (only after npm publish succeeds)
# 6. Alias versioned docs (e.g., v2-5-4.turborepo.dev)
# 7. Create a release branch and open a PR
# 8. On failure, cleanup the staging branch automatically
#
# Canary releases are triggered automatically on push to main.
# Manual releases are triggered via workflow_dispatch.
#
# RECOVERY: If a release fails and cleanup doesn't work, use the
# 'clear-staging-branch' input to manually clear the stale staging branch.

name: Release

env:
  CARGO_PROFILE_RELEASE_LTO: true
  NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
  RELEASE_TURBO_CLI: true # TODO: do we need this?

permissions:
  id-token: write # Required for npm Trusted Publishing using OIDC
  contents: write # Allow workflow to checkout code from the repository
  pull-requests: write # Allows the PR for post-release to be created

on:
  push:
    branches: [main]
    paths:
      - "crates/**"
      - "packages/**"
      - "cli/**"
      - ".github/workflows/**"
      - ".github/actions/**"
  workflow_dispatch:
    inputs:
      increment:
        description: "SemVer Increment (prerelease = bump canary)"
        required: true
        default: "prerelease"
        type: choice
        options:
          # Bump the canary version of the existing semver release
          - prerelease
          # Bump to the next patch version, creating its first canary release
          - prepatch
          # Bump to the next minor version, creating its first canary release
          - preminor
          # Bump to the next major version, creating its first canary release
          - premajor
          # Bump to the next patch version
          - patch
          # Bump to the next minor version
          - minor
          # Bump to the next major version
          - major
      dry_run:
        description: "Do a dry run, skipping the final publish step."
        type: boolean
      tag-override:
        description: "Override default npm dist-tag for the release. Should only be used for backporting"
        required: false
        type: string
      ci-tag-override:
        description: "Override default npm dist-tag to use for running tests. Should only be used when the most recent release was faulty"
        required: false
        type: string
        default: ""
      sha:
        description: "Override the SHA to use for the release. Should rarely be used, usually only for debugging."
        required: false
        type: string
        default: ""
      clear-staging-branch:
        # ┌─────────────────────────────────────────────────────────────────────────────┐
        # │ ⚠️  DANGER ZONE - READ CAREFULLY BEFORE USING                               │
        # ├─────────────────────────────────────────────────────────────────────────────┤
        # │                                                                             │
        # │ This option deletes the staging branch for the version being released,     │
        # │ allowing the release to proceed when a previous release attempt failed.    │
        # │                                                                             │
        # │ ❌ DO NOT USE IF:                                                           │
        # │   • A release workflow is currently running (check the Actions tab!)       │
        # │   • You're unsure why the staging branch exists                            │
        # │   • The npm package for this version was already published                 │
        # │                                                                             │
        # │ ✅ USE ONLY IF:                                                             │
        # │   • A previous release workflow failed or was cancelled                    │
        # │   • No release workflow is currently running for this version              │
        # │   • You've verified the npm package was NOT published (check npm)          │
        # │                                                                             │
        # │ HOW TO VERIFY IT'S SAFE:                                                   │
        # │   1. Check Actions tab - no running release workflows                      │
        # │   2. Run: npm view turbo@<version> - should return "not found"             │
        # │   3. Check git tags: git ls-remote --tags origin | grep <version>          │
        # │      - If tag exists, version was released successfully                    │
        # │                                                                             │
        # └─────────────────────────────────────────────────────────────────────────────┘
        description: "⚠️ DANGER: Delete stale staging branch from a failed release. Only use if previous release failed AND no release is in progress. See workflow file for details."
        type: boolean
        default: false

# Canary releases queue up (rapid merges to main get batched).
# Manual releases each get their own concurrency group.
concurrency:
  group: ${{ github.event_name == 'push' && 'canary-release' || format('release-{0}', github.run_id) }}
  cancel-in-progress: false

jobs:
  check-skip:
    name: "Check Skip Conditions"
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'push' }}
    outputs:
      should_skip: ${{ steps.check.outputs.should_skip }}
    steps:
      - name: Check if release PR merge
        id: check
        env:
          # Use commit author, not github.actor - github.actor is the person who
          # triggered the workflow (e.g., who enabled auto-merge), while the commit
          # author is the bot that created the release commit
          COMMIT_AUTHOR: ${{ github.event.head_commit.author.name }}
          COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          if [[ "$COMMIT_AUTHOR" == "github-actions[bot]" && "$COMMIT_MESSAGE" =~ ^release\(turborepo\): ]]; then
            echo "Skipping: This is a release PR merge (author: $COMMIT_AUTHOR)"
            echo "should_skip=true" >> $GITHUB_OUTPUT
          else
            echo "should_skip=false" >> $GITHUB_OUTPUT
          fi

  stage:
    needs: [check-skip]
    if: ${{ always() && (github.event_name == 'workflow_dispatch' || needs.check-skip.outputs.should_skip != 'true') }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      stage-branch: ${{ steps.stage.outputs.stage-branch }}
      base-sha: ${{ steps.base-sha.outputs.sha }}
      version: ${{ steps.version.outputs.version }}
      previous-tag: ${{ steps.previous-tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ inputs.sha || github.sha }}
          fetch-depth: 0

      - uses: ./.github/actions/setup-node
        with:
          enable-corepack: false

      - name: Configure git
        run: |
          git config --global user.name 'Turbobot'
          git config --global user.email 'turbobot@vercel.com'

      - name: Get base SHA
        id: base-sha
        run: echo "sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT

      - name: Get previous tag
        id: previous-tag
        run: |
          PREV_TAG=$(git tag --list 'v*-canary.*' --sort=-version:refname | head -n 1)
          if [ -z "$PREV_TAG" ]; then
            PREV_TAG=$(git tag --list 'v*' --sort=-version:refname | grep -v canary | head -n 1)
          fi
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT
          echo "Previous tag: $PREV_TAG"

      - name: Clear stale staging branch (if requested)
        if: ${{ inputs.clear-staging-branch }}
        env:
          INCREMENT: ${{ github.event_name == 'push' && 'prerelease' || inputs.increment }}
          TAG_OVERRIDE: ${{ inputs.tag-override }}
        run: |
          echo "::warning::clear-staging-branch was enabled. This should only be used to recover from a failed release."
          echo ""

          # Calculate what version we're about to release so we know which staging branch to delete
          ./scripts/version.js "$INCREMENT" "$TAG_OVERRIDE"
          VERSION=$(head -n 1 version.txt)

          echo "Checking for stale staging branch: staging-${VERSION}"

          if git ls-remote --exit-code --heads origin "staging-${VERSION}" >/dev/null 2>&1; then
            echo "::warning::Deleting staging branch staging-${VERSION}..."
            git push origin --delete "staging-${VERSION}"
            echo "Deleted staging branch staging-${VERSION}"
          else
            echo "No staging branch found for staging-${VERSION}"
          fi

          # Reset version.txt so the Version step can run cleanly
          git checkout version.txt

      - name: Version
        id: version
        env:
          # For push events (canary), always use prerelease. For workflow_dispatch, use the input.
          INCREMENT: ${{ github.event_name == 'push' && 'prerelease' || inputs.increment }}
          TAG_OVERRIDE: ${{ inputs.tag-override }}
        run: |
          if [[ -n "$TAG_OVERRIDE" && ! "$TAG_OVERRIDE" =~ ^[a-zA-Z0-9-]+$ ]]; then
            echo "::error::Invalid tag-override format. Must be alphanumeric with hyphens only."
            exit 1
          fi

          ./scripts/version.js "$INCREMENT" "$TAG_OVERRIDE"
          VERSION=$(head -n 1 version.txt)

          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "::error::Invalid version format produced: $VERSION"
            exit 1
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "New version: $VERSION"
          cat version.txt

      - name: Stage Commit
        id: stage
        run: |
          cd cli && make stage-release
          echo "stage-branch=$(git branch --show-current)" >> $GITHUB_OUTPUT

  rust-smoke-test:
    name: Rust Unit Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [stage]
    if: ${{ always() && needs.stage.result == 'success' }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          node: "false"

      - name: Install cargo-nextest
        uses: taiki-e/install-action@44c6d64aa62cd779e873306675c7a58e86d6d532
        with:
          tool: nextest

      - name: Run tests
        timeout-minutes: 30
        run: cargo nextest run --workspace

  js-smoke-test:
    name: JS Package Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [stage]
    if: ${{ always() && needs.stage.result == 'success' }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}

      - name: Setup Environment
        uses: ./.github/actions/setup-environment
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          rust: "false"
          capnproto: "false"

      - name: Install Global Turbo
        uses: ./.github/actions/install-global-turbo
        with:
          turbo-version: ${{ inputs.ci-tag-override || '' }}

      - name: Run JS Package Tests
        run: turbo run check-types test --filter="./packages/*" --color

  build-rust:
    name: "Build Rust"
    needs: [stage]
    if: ${{ always() && needs.stage.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        settings:
          - host: macos-latest
            target: "x86_64-apple-darwin"
          - host: macos-latest
            target: "aarch64-apple-darwin"
          - host: ubuntu-latest
            target: "x86_64-unknown-linux-musl"
            setup: "sudo apt-get update && sudo apt-get install -y build-essential clang lldb llvm libclang-dev curl musl-tools sudo unzip"
          - host: ubuntu-latest
            target: "aarch64-unknown-linux-musl"
            rust-build-env: 'CC_aarch64_unknown_linux_musl=clang AR_aarch64_unknown_linux_musl=llvm-ar RUSTFLAGS="-Clink-self-contained=yes -Clinker=rust-lld"'
            setup: "sudo apt-get update && sudo apt-get install -y build-essential musl-tools clang llvm gcc-aarch64-linux-gnu binutils-aarch64-linux-gnu"
          - host: windows-latest
            target: x86_64-pc-windows-msvc
    runs-on: ${{ matrix.settings.host }}
    timeout-minutes: 30
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}

      - name: Setup Protoc
        uses: ./.github/actions/setup-protoc
        with:
          version: "26.x"
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup capnproto
        uses: ./.github/actions/setup-capnproto

      - name: Rust Setup
        uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          target: ${{ matrix.settings.target }}
          # needed to not make it override the defaults
          rustflags: ""
          # we want more specific settings
          cache: false

      - name: Build Setup
        if: ${{ matrix.settings.setup }}
        run: ${{ matrix.settings.setup }}

      - name: Build
        run: ${{ matrix.settings.rust-build-env }} cargo build --profile release-turborepo -p turbo --target ${{ matrix.settings.target }}

      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: turbo-${{ matrix.settings.target }}
          path: target/${{ matrix.settings.target }}/release-turborepo/turbo*

  npm-publish:
    name: "Publish To NPM"
    runs-on: ubuntu-latest
    timeout-minutes: 30
    needs: [stage, build-rust, rust-smoke-test, js-smoke-test]
    if: ${{ always() && needs.stage.result == 'success' && needs.build-rust.result == 'success' && needs.rust-smoke-test.result == 'success' && needs.js-smoke-test.result == 'success' }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}

      - run: git fetch origin --tags

      - uses: ./.github/actions/setup-node
        with:
          enable-corepack: false

      - name: Install Global Turbo
        uses: ./.github/actions/install-global-turbo
        with:
          turbo-version: ${{ inputs.ci-tag-override || '' }}

      - name: Configure git
        run: |
          git config --global user.name 'Turbobot'
          git config --global user.email 'turbobot@vercel.com'

      - name: Download Rust artifacts
        uses: actions/download-artifact@v4
        with:
          path: rust-artifacts

      - name: Move Rust artifacts into place
        run: |
          mv rust-artifacts/turbo-aarch64-apple-darwin cli/dist-darwin-arm64
          mv rust-artifacts/turbo-aarch64-unknown-linux-musl cli/dist-linux-arm64
          cp -r rust-artifacts/turbo-x86_64-pc-windows-msvc cli/dist-windows-arm64
          mv rust-artifacts/turbo-x86_64-unknown-linux-musl cli/dist-linux-x64
          mv rust-artifacts/turbo-x86_64-apple-darwin cli/dist-darwin-x64
          mv rust-artifacts/turbo-x86_64-pc-windows-msvc cli/dist-windows-x64

      - name: Ensure npm version
        run: npm install -g npm@11.5.1

      - name: Perform Release
        run: |
          SKIP_FLAG=""
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            SKIP_FLAG="--skip-publish"
          fi
          cd cli && make publish-turbo SKIP_PUBLISH=$SKIP_FLAG

      # Upload published artifacts in case they are needed for debugging later
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: turbo-combined
          path: cli/dist

  create-release-tag:
    name: "Create Release Tag"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [stage, npm-publish]
    if: ${{ always() && !inputs.dry_run && needs.npm-publish.result == 'success' }}
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}
          fetch-depth: 0

      - name: Configure git
        run: |
          git config --global user.name 'Turbobot'
          git config --global user.email 'turbobot@vercel.com'

      - name: Create and push release tag
        run: cd cli && make create-release-tag

  alias-versioned-docs:
    name: "Alias Versioned Docs"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [stage, npm-publish]
    if: ${{ always() && !inputs.dry_run && needs.npm-publish.result == 'success' }}
    outputs:
      success: ${{ steps.alias.outcome == 'success' }}
      subdomain: ${{ steps.version.outputs.subdomain }}
      version: ${{ steps.version.outputs.version }}
      docs_url: ${{ steps.alias.outputs.docs_url }}
    steps:
      - name: Checkout staging branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}

      - name: Get version and compute subdomain
        id: version
        run: |
          VERSION=$(head -n 1 version.txt)
          # Transform version to valid subdomain (replace dots with dashes, prepend v)
          SUBDOMAIN=$(echo "v${VERSION}" | tr '.' '-')
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "subdomain=${SUBDOMAIN}" >> $GITHUB_OUTPUT

      - name: Install Vercel CLI
        run: npm install -g vercel@latest

      - name: Find Vercel deployment for SHA
        id: find-deployment
        env:
          VERCEL_TOKEN: ${{ secrets.TURBO_TOKEN }}
        run: |
          SHA="${{ needs.stage.outputs.base-sha }}"
          DEPLOYMENT_URL=$(vercel list turbo-site --scope=vercel -m githubCommitSha="${SHA}" --status=READY --token="${VERCEL_TOKEN}" 2>&1 | tee /dev/stderr | grep -E '^\S+\.vercel\.(app|sh)' | head -n 1 | awk '{print $1}')

          if [ -z "$DEPLOYMENT_URL" ]; then
            echo "::error::No deployment found for SHA ${SHA}."
            exit 1
          fi

          echo "deployment_url=${DEPLOYMENT_URL}" >> $GITHUB_OUTPUT

      - name: Assign subdomain alias
        id: alias
        env:
          VERCEL_TOKEN: ${{ secrets.TURBO_TOKEN }}
        run: |
          ALIAS="${{ steps.version.outputs.subdomain }}.turborepo.dev"
          DEPLOYMENT_URL="${{ steps.find-deployment.outputs.deployment_url }}"
          vercel alias set "${DEPLOYMENT_URL}" "${ALIAS}" --token="${VERCEL_TOKEN}" --scope=vercel
          echo "docs_url=https://${ALIAS}" >> $GITHUB_OUTPUT

      - name: Notify Slack on failure
        if: failure()
        uses: slackapi/slack-github-action@v1.23.0
        with:
          payload: |
            {
              "text": "Versioned docs aliasing failed for v${{ steps.version.outputs.version }}",
              "blocks": [
                {
                  "type": "header",
                  "text": { "type": "plain_text", "text": "Versioned Docs Aliasing Failed" }
                },
                {
                  "type": "section",
                  "fields": [
                    { "type": "mrkdwn", "text": "*Version:*\nv${{ steps.version.outputs.version }}" },
                    { "type": "mrkdwn", "text": "*Subdomain:*\n${{ steps.version.outputs.subdomain }}.turborepo.dev" }
                  ]
                },
                {
                  "type": "section",
                  "text": { "type": "mrkdwn", "text": "*Workflow:*\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>" }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.DOCS_ALIAS_FAILURE_SLACK_WEBHOOK_URL }}

  create-release-pr:
    name: "Open Release Branch PR"
    needs: [stage, npm-publish, create-release-tag, alias-versioned-docs]
    if: ${{ always() && needs.npm-publish.result == 'success' && needs.create-release-tag.result == 'success' && github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}

      - name: Get version
        id: getVersion
        run: echo "version=$(head -n 1 version.txt)" >> $GITHUB_OUTPUT

      - name: Build PR Body
        id: pr-body
        run: |
          if [ "${{ needs.alias-versioned-docs.result }}" != "success" ]; then
            echo "> [!CAUTION]" > pr-body.md
            echo "> Versioned docs aliasing FAILED. [View logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> pr-body.md
            echo "" >> pr-body.md
          else
            echo "Versioned docs: https://${{ needs.alias-versioned-docs.outputs.subdomain }}.turborepo.dev" > pr-body.md
            echo "" >> pr-body.md
          fi
          echo "Release PR for turborepo v${{ steps.getVersion.outputs.version }}" >> pr-body.md

      - name: Create pull request
        uses: thomaseizinger/create-pull-request@master
        if: ${{ !inputs.dry_run }}
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          head: ${{ needs.stage.outputs.stage-branch }}
          base: main
          title: "release(turborepo): ${{ steps.getVersion.outputs.version }}"
          body-path: pr-body.md

  create-canary-pr:
    name: "Open Canary Release PR"
    needs: [stage, npm-publish, create-release-tag, alias-versioned-docs]
    if: ${{ always() && needs.npm-publish.result == 'success' && needs.create-release-tag.result == 'success' && github.event_name == 'push' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ needs.stage.outputs.stage-branch }}
          fetch-depth: 0

      - name: Fetch main and tags
        run: git fetch origin main --tags

      - name: Validate version format
        run: |
          VERSION="${{ needs.stage.outputs.version }}"
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "::error::Invalid version format: $VERSION"
            exit 1
          fi

      - name: Build PR Body
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREVIOUS_TAG="${{ needs.stage.outputs.previous-tag }}"
          VERSION="${{ needs.stage.outputs.version }}"
          DOCS_URL="${{ needs.alias-versioned-docs.outputs.docs_url }}"

          echo "## Canary Release" > pr-body.md
          echo "" >> pr-body.md

          if [ -n "$DOCS_URL" ]; then
            echo "Versioned docs: ${DOCS_URL}" >> pr-body.md
            echo "" >> pr-body.md
          fi

          echo "### Included Changes" >> pr-body.md
          echo "" >> pr-body.md

          if [ -n "$PREVIOUS_TAG" ]; then
            git log ${PREVIOUS_TAG}..origin/main --pretty=format:"%H %s" | while read -r line; do
              SHA=$(echo "$line" | cut -d' ' -f1)
              SHORT_SHA=$(echo "$SHA" | cut -c1-7)
              MESSAGE=$(echo "$line" | cut -d' ' -f2-)
              PR_NUM=$(gh api "/repos/${{ github.repository }}/commits/${SHA}/pulls" --jq '.[0].number' 2>/dev/null || echo "")

              if [ -n "$PR_NUM" ]; then
                echo "- ${SHORT_SHA} - ${MESSAGE} (#${PR_NUM})" >> pr-body.md
              else
                echo "- ${SHORT_SHA} - ${MESSAGE}" >> pr-body.md
              fi
            done
          else
            echo "No previous tag found. This is the first canary release." >> pr-body.md
          fi

          echo "" >> pr-body.md
          echo "---" >> pr-body.md
          echo "Release PR for turborepo v${VERSION}" >> pr-body.md

      - name: Create pull request with auto-merge
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.stage.outputs.version }}"
          STAGE_BRANCH="${{ needs.stage.outputs.stage-branch }}"
          MAX_RETRIES=3
          RETRY_DELAY=10

          for i in $(seq 1 $MAX_RETRIES); do
            if PR_URL=$(gh pr create \
              --title "release(turborepo): ${VERSION}" \
              --body-file pr-body.md \
              --head "${STAGE_BRANCH}" \
              --base main 2>&1); then
              break
            fi
            echo "PR creation attempt $i failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done

          if [ -z "$PR_URL" ] || [[ ! "$PR_URL" =~ ^https://github.com/.*/pull/[0-9]+$ ]]; then
            echo "::error::Failed to create PR after $MAX_RETRIES attempts. Output: $PR_URL"
            exit 1
          fi

          echo "Created PR: $PR_URL"
          PR_NUM=$(echo "$PR_URL" | grep -oE '[0-9]+$')

          MERGE_SUCCESS=false
          for i in $(seq 1 $MAX_RETRIES); do
            if gh pr merge "$PR_NUM" --auto --squash; then
              MERGE_SUCCESS=true
              break
            fi
            echo "Auto-merge attempt $i failed, retrying in ${RETRY_DELAY}s..."
            sleep $RETRY_DELAY
          done

          if [ "$MERGE_SUCCESS" != "true" ]; then
            echo "::warning::Failed to enable auto-merge after $MAX_RETRIES attempts. PR created but requires manual merge: $PR_URL"
          fi

  cleanup-on-failure:
    name: "Cleanup Failed Release"
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [stage, build-rust, rust-smoke-test, js-smoke-test, npm-publish]
    if: ${{ always() && needs.stage.result == 'success' && (needs.build-rust.result == 'failure' || needs.rust-smoke-test.result == 'failure' || needs.js-smoke-test.result == 'failure' || needs.npm-publish.result == 'failure') }}
    steps:
      - name: Delete staging branch
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          STAGE_BRANCH="${{ needs.stage.outputs.stage-branch }}"
          echo "::warning::Release failed. Cleaning up staging branch ${STAGE_BRANCH}..."
          gh api -X DELETE "repos/${{ github.repository }}/git/refs/heads/${STAGE_BRANCH}" || echo "Branch may already be deleted or not exist"
          echo "Cleanup complete. You can retry the release without using clear-staging-branch."
